import Data.Char(isLetter)
import Data.List(nub)

-- От Упражнение 6:
-- Задача 6. Нека as = [a1, a2 … , ak] и bs = [b1, b2 … , bk] са непразни списъци с еднакъв брой числа.
-- Да се дефинира предикат isImage :: [Int] -> [Int] -> Bool, който да връща „истина“ точно когато съществува такова число x, че ai = x + bi за всяко i = 1,..., k.

-- 1ви вариант
isImage :: [Int] -> [Int] -> Bool
isImage (a:as) (b:bs) = (a:as) == map (+ (a - b)) (b:bs)

-- 2ри вариант - ползвайки синоними за да избегнем повторенията
isImage' :: [Int] -> [Int] -> Bool
isImage' as@(a:_) bs@(b:_) = as == map (+ (a - b)) bs
-- @ е начин за създаване на синоними, т.е. тук as и (а:_) са две имена на една и съша стойност - списък с първи елемент а и произволна опашка

-- 3ти вариант - с all
isImage'' :: [Int] -> [Int] -> Bool
isImage'' (a1:as) (b1:bs) = all (\ (ai, bi) -> ai == x + bi) (zip as bs)
    where x = a1 - b1

-- Задача 7. Да се дефинира предикат isTriangular :: [[Int]] -> Bool, който получава квадратна числова матрица, представена като списък от списъци, 
-- и проверява дали тя е горно триъгълна, т.е. дали всичките елементи под главния ѝ диагонал са нули.
isTriangular :: [[Int]] -> Bool
isTriangular []  = True
isTriangular mss = all (== 0) (tail (map head mss)) && isTriangular (tail (map tail mss))

matrix :: [[Int]]  -- матрицата представяме като списък от списъци - всеки елемент представлява един ред
matrix = [[1,2,3], -- за да бъде квадратна, трябва всички редове да имат равен брой елементи и този брой да е равен на броя редове (т.е. елементи в списъка от списъци)
          [0,5,6], -- чрез map head получаваме първата колона. Като вземем нейния tail, ще получим елементите в първата колона под главния диагонал
          [0,0,9]] -- чрез map tail получаваме матрицата без първата колона. Като вземем нейния tail, ще махнем и първия ред


-- Допълнителни задачи за упражнение:
-- Задача 1. Да се провери дали елементите на даден списък от цели числа са с алтернативни значи. В списъка не присъства числото 0.
signCheck :: [Int] -> Bool
signCheck []         = True
signCheck [_]        = True
signCheck (x1:x2:xs) = (x1 * x2 < 0) && signCheck (x2:xs)  
-- ако две ненулеви числа са с различни знаци, то едното от тях е отрицателно, значи произведението им също ще е отрицателно
-- друг вариант за проверката е ((x1 < 0 && x2 > 0) || (x1 > 0 && x2 < 0))

signCheck' :: [Int] -> Bool
signCheck' xs = all (\ (a,b) -> a * b < 0) (zip xs (tail xs))

-- Задача 2. Да се провери дали даден списък задава аритметична прогресия.
isArith :: [Int] -> Bool
isArith []             = True
isArith [_]            = True
isArith lst@(x1:x2:xs) = lst == [x1, x2 .. (last xs)]

isArith' :: [Int] -> Bool
isArith' []  = True
isArith' [_] = True
isArith' xs  = isImage'' xs (tail xs) 
-- ако списъкът наистина задава прогресия, то всеки два поредни елемента ще имат една и съща разлика. Така самият той и опашката му ще изпълняват условието в isImage, 
-- с разликата, че няма да са с еднаква дължина, но третият вариант на isImage ще се оправи, тъй като той извиква функцията zip, а тя може да борави с такива списъци.
-- Другите варианти на isImage не работят, тъй като те сравняват списъци за равенство, а списъци с различна дължина винаги са различни.

-- Задача 3. Да се напише функция, която приема дума word и връща списък от двойки (x, xCount), където x е буква от word, а xCount - броят срещания на x в word.
countLetters :: String -> [(Char, Int)]
countLetters word = [(letter, count letter word) | letter <- letters]
    where 
        count x xs = length [y | y <- xs, y == x]
        letters = filter isLetter (nub word) 
        -- nub е вградена функция, която премахва повторенията в списък. Така от думата може да получим списък, в който всеки символ участващ в нея се среща точно веднъж.
        -- Той ще съдържа и небуквени символи (числа, интервали), затова филтрираме и оставяме само буквите.
        

main :: IO()
main = do
    --print (isImage [1,2,3] [4,5,6]) -- -> True
    --print (isImage [1,2,3] [4,5,7]) -- -> False

    {-
    print matrix                    -- -> [[1,2,3],
                                    --     [0,5,6],
                                    --     [0,0,9]]

    print (map head matrix)         -- -> [1,
                                    --     0,
                                    --     0]

    print (tail (map head matrix))  -- -> [0,
                                    --     0]

    print (map tail matrix)         -- -> [[2,3],
                                    --     [5,6],
                                    --     [0,9]]

    print (tail (map tail matrix))  -- -> [[5,6],
                                    --     [0,9]]

    print (isTriangular [[1,2,3], [0,5,6], [0,0,9]]) -- -> True
    print (isTriangular [[1,2,3], [4,0,6], [0,0,9]]) -- -> False -}

    --print (signCheck' [1, -2, 3, -4, 5, -6]) -- -> True
    --print (signCheck' [1, -2, 3, 4, 5, -6])  -- -> False

    --print (isArith [1,4,7,10]) -- -> True
    --print (isArith [1,4,6,9])  -- -> False

    --print (countLetters "This is a sentence") -- -> [('T',1),('h',1),('i',2),('s',3),('a',1),('e',3),('n',2),('t',1),('c',1)]